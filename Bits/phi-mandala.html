<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PHI Lattice — Hardware Store</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Cinzel:wght@400;600&display=swap');

:root {
–phi: 1.6180339887;
–bg: #0a0a0f;
–bg2: #0f0f1a;
–gold: #c9a84c;
–gold2: #f0d080;
–copper: #b87333;
–teal: #2dd4bf;
–rose: #fb7185;
–violet: #a78bfa;
–text: #e8e0d0;
–dim: #6b6460;
–orbit1: rgba(201,168,76,0.15);
–orbit2: rgba(45,212,191,0.08);
–orbit3: rgba(167,139,250,0.06);
}

- { margin: 0; padding: 0; box-sizing: border-box; }

body {
background: var(–bg);
color: var(–text);
font-family: ‘Space Mono’, monospace;
min-height: 100vh;
overflow-x: hidden;
}

/* Starfield background */
body::before {
content: ‘’;
position: fixed;
inset: 0;
background-image:
radial-gradient(1px 1px at 20% 30%, rgba(255,255,255,0.3) 0%, transparent 100%),
radial-gradient(1px 1px at 80% 10%, rgba(255,255,255,0.2) 0%, transparent 100%),
radial-gradient(1px 1px at 50% 80%, rgba(255,255,255,0.25) 0%, transparent 100%),
radial-gradient(1px 1px at 10% 60%, rgba(255,255,255,0.15) 0%, transparent 100%),
radial-gradient(1px 1px at 90% 70%, rgba(255,255,255,0.2) 0%, transparent 100%),
radial-gradient(2px 2px at 35% 15%, rgba(201,168,76,0.4) 0%, transparent 100%),
radial-gradient(1px 1px at 65% 45%, rgba(45,212,191,0.3) 0%, transparent 100%);
pointer-events: none;
z-index: 0;
}

header {
text-align: center;
padding: 2rem 1rem 0.5rem;
position: relative;
z-index: 10;
}

header h1 {
font-family: ‘Cinzel’, serif;
font-size: clamp(1.2rem, 3vw, 2rem);
color: var(–gold);
letter-spacing: 0.3em;
text-transform: uppercase;
}

header p {
font-size: 0.7rem;
color: var(–dim);
margin-top: 0.4rem;
letter-spacing: 0.15em;
}

.container {
display: flex;
flex-direction: column;
align-items: center;
padding: 1rem;
position: relative;
z-index: 1;
}

/* Canvas wrapper */
#mandala-wrap {
position: relative;
width: min(90vw, 600px);
height: min(90vw, 600px);
}

canvas {
position: absolute;
top: 0; left: 0;
width: 100%;
height: 100%;
}

#mandala-canvas { z-index: 1; }
#interaction-canvas { z-index: 2; cursor: crosshair; }

/* Info panel */
#info-panel {
width: min(90vw, 600px);
margin-top: 1.5rem;
border: 1px solid rgba(201,168,76,0.2);
background: rgba(10,10,15,0.9);
backdrop-filter: blur(10px);
padding: 1.2rem;
min-height: 160px;
position: relative;
overflow: hidden;
}

#info-panel::before {
content: ‘’;
position: absolute;
top: 0; left: 0; right: 0;
height: 1px;
background: linear-gradient(90deg, transparent, var(–gold), transparent);
}

#info-panel .hint {
color: var(–dim);
font-size: 0.7rem;
letter-spacing: 0.1em;
text-align: center;
margin-top: 2rem;
}

#node-display { display: none; }
#node-display.active { display: block; }
#hint-text { display: block; }
#hint-text.hidden { display: none; }

.node-header {
display: flex;
justify-content: space-between;
align-items: flex-start;
margin-bottom: 0.8rem;
flex-wrap: wrap;
gap: 0.5rem;
}

.node-id {
font-family: ‘Cinzel’, serif;
font-size: 1.1rem;
color: var(–gold);
}

.node-note {
font-size: 1.4rem;
color: var(–teal);
font-weight: bold;
}

.node-spin {
font-size: 0.8rem;
padding: 0.2rem 0.5rem;
border-radius: 2px;
}
.spin-up { background: rgba(45,212,191,0.15); color: var(–teal); border: 1px solid rgba(45,212,191,0.3); }
.spin-down { background: rgba(251,113,133,0.15); color: var(–rose); border: 1px solid rgba(251,113,133,0.3); }

.spec-grid {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 0.6rem;
margin-bottom: 0.8rem;
}

.spec-item {
background: rgba(255,255,255,0.03);
border: 1px solid rgba(255,255,255,0.06);
padding: 0.4rem 0.5rem;
}

.spec-label {
font-size: 0.55rem;
color: var(–dim);
text-transform: uppercase;
letter-spacing: 0.1em;
display: block;
}

.spec-value {
font-size: 0.8rem;
color: var(–text);
font-weight: bold;
}

.phi-bar {
height: 2px;
background: linear-gradient(90deg, var(–gold), var(–teal));
margin-bottom: 0.6rem;
position: relative;
}

.phi-bar::after {
content: ‘φ = 1.6180…’;
position: absolute;
right: 0;
top: 4px;
font-size: 0.55rem;
color: var(–dim);
}

.links-row {
font-size: 0.65rem;
color: var(–dim);
}

.links-row span {
color: var(–violet);
margin-left: 0.3rem;
}

.puzzle-hint {
margin-top: 0.6rem;
padding: 0.4rem 0.6rem;
border-left: 2px solid var(–copper);
font-size: 0.6rem;
color: var(–dim);
font-style: italic;
}

/* API docs strip */
#api-strip {
width: min(90vw, 600px);
margin-top: 1rem;
display: grid;
grid-template-columns: 1fr 1fr;
gap: 0.5rem;
}

.api-endpoint {
background: rgba(15,15,26,0.8);
border: 1px solid rgba(201,168,76,0.1);
padding: 0.6rem 0.8rem;
font-size: 0.6rem;
cursor: pointer;
transition: border-color 0.2s;
}

.api-endpoint:hover {
border-color: rgba(201,168,76,0.4);
}

.api-method {
color: var(–teal);
font-weight: bold;
display: block;
margin-bottom: 0.2rem;
}

.api-path { color: var(–gold2); }
.api-desc { color: var(–dim); margin-top: 0.2rem; display: block; }

#api-response {
width: min(90vw, 600px);
margin-top: 0.5rem;
display: none;
background: rgba(5,5,10,0.95);
border: 1px solid rgba(45,212,191,0.2);
padding: 0.8rem;
font-size: 0.6rem;
color: var(–teal);
white-space: pre;
overflow-x: auto;
max-height: 200px;
overflow-y: auto;
}

#api-response.active { display: block; }

footer {
text-align: center;
padding: 2rem 1rem;
font-size: 0.6rem;
color: var(–dim);
letter-spacing: 0.15em;
position: relative;
z-index: 1;
}

/* Pulse animation for selected node */
@keyframes pulse-ring {
0% { opacity: 0.8; }
50% { opacity: 0.3; }
100% { opacity: 0.8; }
}

.loading {
text-align: center;
padding: 3rem;
color: var(–dim);
font-size: 0.7rem;
letter-spacing: 0.2em;
}
</style>

</head>
<body>

<header>
  <h1>PHI Lattice · Hardware Store</h1>
  <p>GET /pieces/{node_id} · GET /graph/{nodes} · POST /build/mandala · Inventory anonymized</p>
</header>

<div class="container">
  <div id="mandala-wrap">
    <canvas id="mandala-canvas"></canvas>
    <canvas id="interaction-canvas"></canvas>
  </div>

  <div id="info-panel">
    <div id="hint-text" class="hint">
      ↑ click any node to query · hover to preview · all specifications accurate
    </div>
    <div id="node-display">
      <div class="node-header">
        <div>
          <div class="node-id" id="nd-id">—</div>
          <div style="font-size:0.6rem;color:var(--dim);margin-top:0.2rem" id="nd-category">—</div>
        </div>
        <div class="node-note" id="nd-note">—</div>
        <div class="node-spin" id="nd-spin">—</div>
      </div>
      <div class="phi-bar"></div>
      <div class="spec-grid">
        <div class="spec-item">
          <span class="spec-label">diameter</span>
          <span class="spec-value" id="nd-diam">—</span>
        </div>
        <div class="spec-item">
          <span class="spec-label">length</span>
          <span class="spec-value" id="nd-len">—</span>
        </div>
        <div class="spec-item">
          <span class="spec-label">orbit</span>
          <span class="spec-value" id="nd-orbit">—</span>
        </div>
        <div class="spec-item">
          <span class="spec-label">phi index</span>
          <span class="spec-value" id="nd-phi">—</span>
        </div>
        <div class="spec-item">
          <span class="spec-label">weight</span>
          <span class="spec-value" id="nd-weight">—</span>
        </div>
        <div class="spec-item">
          <span class="spec-label">bond angle</span>
          <span class="spec-value" id="nd-bond">—</span>
        </div>
      </div>
      <div class="links-row">covalent links: <span id="nd-links">—</span></div>
      <div class="puzzle-hint" id="nd-puzzle">—</div>
    </div>
  </div>

  <div id="api-strip">
    <div class="api-endpoint" onclick="callAPI('pieces','UNI001')">
      <span class="api-method">GET</span>
      <span class="api-path">/pieces/UNI001</span>
      <span class="api-desc">node properties + geometry</span>
    </div>
    <div class="api-endpoint" onclick="callAPI('graph','UNI001-UNI002-UNI003')">
      <span class="api-method">GET</span>
      <span class="api-path">/graph/UNI001-UNI002-UNI003</span>
      <span class="api-desc">subgraph + mandala stability</span>
    </div>
    <div class="api-endpoint" onclick="callAPI('build','mandala')">
      <span class="api-method">POST</span>
      <span class="api-path">/build/mandala</span>
      <span class="api-desc">generate phi-scaled lattice</span>
    </div>
    <div class="api-endpoint" onclick="callAPI('validate','MANDALA_001')">
      <span class="api-method">GET</span>
      <span class="api-path">/validate/lattice/MANDALA_001</span>
      <span class="api-desc">global integrity check</span>
    </div>
  </div>

  <div id="api-response"></div>
</div>

<footer>
  hardware-store · bits · phi-lattice · pattern-seers welcome · inventory anonymized<br>
  built during a snowstorm · 45mph gusts · warm inside · CC0
</footer>

<script>
const PHI = 1.6180339887;

// Multi-lattice loader — reads manifest.json, loads all enabled lattices
let NODES = [];
let LATTICE_META = {};
let ACTIVE_FILTERS = new Set(['hardware','animals','color']);

function normalize(n, latticeId) {
  const orbit = n.orbit ?? n.orbit_radius ?? 1;
  return {
    ...n,
    lattice: latticeId,
    orbit,
    phi_index: n.phi_index ?? Math.max(0, Math.round(Math.log(Math.max(orbit,1)) / Math.log(PHI))),
    bond_angle: n.bond_angle ?? 109.5,
    puzzle: n.puzzle ?? n.description ?? '',
    note: n.musical_note ?? n.note ?? '?',
    hex: n.hex ?? null
  };
}

async function tryFetch(paths) {
  for (const p of paths) {
    try {
      const r = await fetch(p);
      if (r.ok) return { data: await r.json(), path: p };
    } catch(e) {}
  }
  return null;
}

async function loadNodes() {
  document.getElementById('hint-text').textContent = '⟳ loading manifest...';

  // Try manifest first
  const manifestResult = await tryFetch([
    './Bits/manifest.json', '../Bits/manifest.json', 'manifest.json'
  ]);

  if (manifestResult) {
    const manifest = manifestResult.data;
    const base = manifestResult.path.replace('manifest.json','');
    LATTICE_META = {};
    NODES = [];

    for (const lattice of manifest.lattices) {
      if (!lattice.enabled) continue;
      LATTICE_META[lattice.id] = lattice;

      const result = await tryFetch([
        base + lattice.file,
        './Bits/' + lattice.file,
        lattice.file
      ]);

      if (result) {
        const nodes = result.data.map(n => normalize(n, lattice.id));
        NODES.push(...nodes);
        console.log(`Loaded ${nodes.length} nodes from ${lattice.id} (${result.path})`);
      }
    }

    buildFilterUI(manifest.lattices);
    updateHint();
    return true;
  }

  // Fallback — try individual files
  const sources = [
    { id: 'hardware', file: './Bits/pieces.json' },
    { id: 'animals',  file: './Bits/animal-pieces.json' },
    { id: 'color',    file: './Bits/color-pieces.json' }
  ];

  for (const s of sources) {
    const result = await tryFetch([s.file, s.file.replace('./Bits/','')]);
    if (result) {
      NODES.push(...result.data.map(n => normalize(n, s.id)));
    }
  }

  if (NODES.length > 0) {
    updateHint();
    return true;
  }

  // Final fallback
  NODES = FALLBACK_NODES.map(n => normalize(n, 'hardware'));
  updateHint();
  return false;
}

function updateHint() {
  const visible = NODES.filter(n => ACTIVE_FILTERS.has(n.lattice)).length;
  document.getElementById('hint-text').textContent =
    `↑ ${visible} nodes · ${NODES.length} total · click any node to query · all specifications accurate`;
}

function buildFilterUI(lattices) {
  const strip = document.getElementById('api-strip');
  const filterBar = document.createElement('div');
  filterBar.id = 'filter-bar';
  filterBar.style.cssText = `
    display:flex; gap:0.5rem; margin-bottom:0.5rem;
    flex-wrap:wrap; width:100%;
  `;

  lattices.forEach(lat => {
    if (!lat.enabled) return;
    const btn = document.createElement('button');
    btn.textContent = lat.label;
    btn.dataset.lattice = lat.id;
    btn.style.cssText = `
      background: ${lat.color_key}22;
      border: 1px solid ${lat.color_key}88;
      color: ${lat.color_key};
      font-family: 'Space Mono', monospace;
      font-size: 0.65rem;
      padding: 0.3rem 0.7rem;
      cursor: pointer;
      letter-spacing: 0.1em;
      transition: all 0.2s;
    `;
    btn.addEventListener('click', () => toggleFilter(lat.id, lat.color_key, btn));
    filterBar.appendChild(btn);
  });

  // Insert before api-strip
  strip.parentNode.insertBefore(filterBar, strip);
}

function toggleFilter(latticeId, color, btn) {
  if (ACTIVE_FILTERS.has(latticeId)) {
    if (ACTIVE_FILTERS.size > 1) { // keep at least one
      ACTIVE_FILTERS.delete(latticeId);
      btn.style.opacity = '0.35';
    }
  } else {
    ACTIVE_FILTERS.add(latticeId);
    btn.style.opacity = '1';
  }
  updateHint();
  computePositions();
}

// Fallback inline data (used when pieces.json not reachable)
const FALLBACK_NODES = [
  {
    id: 'UNI001', category: 'fastener', note: 'C4', spin: 'up',
    diameter_mm: 3, length_mm: 5, weight_g: 2,
    orbit: 1, phi_index: 0,
    links: ['UNI002','UNI003','UNI008'],
    bond_angle: 109.5,
    puzzle: 'Center node. Orbit 1. C4 = 261.63 Hz. 261.63 × φ = 423.2 Hz ≈ G#4. Why is the center not G#4?',
    description: 'Central mandala node. Phi origin. All orbits scale from here.'
  },
  {
    id: 'UNI002', category: 'connector', note: 'D4', spin: 'up',
    diameter_mm: 5, length_mm: 8, weight_g: 3,
    orbit: 1.001, phi_index: 1,
    links: ['UNI001','UNI004'],
    bond_angle: 109.5,
    puzzle: 'Orbit 1.001. Almost 1. The deviation is 0.001. Is this rounding or intentional? Check orbit 75.002.',
    description: 'First shell. Near-unity orbit. D4 harmonic.'
  },
  {
    id: 'UNI003', category: 'bracket', note: 'A4', spin: 'down',
    diameter_mm: 3, length_mm: 55, weight_g: 4,
    orbit: 10.084, phi_index: 5,
    links: ['UNI001','UNI005'],
    bond_angle: 120,
    puzzle: '3mm × 55mm. Fibonacci adjacent: 3,5,8,13,21,34,55. The length is F(10). The diameter is F(4). What is F(10)/F(4)?',
    description: 'Fibonacci dimensions. Spin down. A4 = 440 Hz standard tuning reference.'
  },
  {
    id: 'UNI004', category: 'fastener', note: 'F4', spin: 'up',
    diameter_mm: 13, length_mm: 5, weight_g: 5,
    orbit: 8.236, phi_index: 4,
    links: ['UNI002','UNI007'],
    bond_angle: 109.5,
    puzzle: 'Orbit 8.236 = 5φ + 3 = 8 + 0.236... The decimal 0.236 = φ - 1 = 1/φ. Orbit encodes phi in its fractional part.',
    description: 'Phi-encoded orbit. 13mm diameter = F(7). F4 harmonic.'
  },
  {
    id: 'UNI005', category: 'pipe', note: 'G4', spin: 'up',
    diameter_mm: 21, length_mm: 84, weight_g: 8,
    orbit: 6.618, phi_index: 3,
    links: ['UNI002','UNI003','UNI010'],
    bond_angle: 120,
    puzzle: '21mm / 84mm. 84/21 = 4. But 21 = F(8), 84 = 4×F(8). Orbit 6.618 = 4 + φ + 1 = 4 + 2.618. Why 4?',
    description: 'G4. Fibonacci dimensions. Orbit = integer + φ - 1.'
  },
  {
    id: 'UNI006', category: 'connector', note: 'B4', spin: 'up',
    diameter_mm: 51, length_mm: 55, weight_g: 12,
    orbit: 4.228, phi_index: 2,
    links: ['UNI007','UNI008'],
    bond_angle: 109.5,
    puzzle: 'Orbit 4.228 = φ³ - 0.0... φ³ = 4.236. Almost. What is 4.228 actually? Check if it encodes something else.',
    description: 'Near-phi-cube orbit. B4 harmonic. Both dimensions Fibonacci-adjacent.'
  },
  {
    id: 'UNI007', category: 'bracket', note: 'B4', spin: 'up',
    diameter_mm: 54, length_mm: 55, weight_g: 13,
    orbit: 4.228, phi_index: 2,
    links: ['UNI004','UNI006'],
    bond_angle: 120,
    puzzle: 'UNI006 and UNI007 share an orbit and a note. Twins. Why are there two nodes at the same orbital radius? What does degeneracy mean in atomic physics?',
    description: 'Degenerate orbit twin of UNI006. Same energy level, different position.'
  },
  {
    id: 'UNI008', category: 'fastener', note: 'G4/E5', spin: 'up',
    diameter_mm: 3, length_mm: 55, weight_g: 6,
    orbit: 108, phi_index: 7,
    links: ['UNI001','UNI006','UNI009'],
    bond_angle: 109.5,
    puzzle: 'Orbit 108. 108 = 100 + 8 = φ⁰×100 + φ³×... or: 108/φ = 66.77 ≈ orbit of UNI009. The orbits are phi-related.',
    description: 'High orbit. G4 or E5 depending on reference frame. Dual note = harmonic ambiguity.'
  },
  {
    id: 'UNI009', category: 'pipe', note: 'D5', spin: 'up',
    diameter_mm: 114, length_mm: 34, weight_g: 15,
    orbit: 66.834, phi_index: 6,
    links: ['UNI008','UNI010'],
    bond_angle: 120,
    puzzle: '114mm / 34mm. 114 = 2×57 = 2×3×19. 34 = F(9). But 114/34 = 3.35... ≈ φ²? φ² = 2.618. Not quite. What ratio is 3.35?',
    description: 'D5. Outer shell. 34mm = Fibonacci. High orbit.'
  },
  {
    id: 'UNI010', category: 'connector', note: 'E5', spin: 'up',
    diameter_mm: 233, length_mm: 377, weight_g: 20,
    orbit: 75.002, phi_index: 8,
    links: ['UNI005','UNI009'],
    bond_angle: 109.5,
    puzzle: '233mm / 377mm. These ARE consecutive Fibonacci: F(13)/F(14) = 233/377. 377/233 = 1.6180... = φ. The fastener dimensions prove phi. The orbit 75.002 ≈ 75 + 0.002. What is 75?',
    description: 'PROOF NODE. Dimensions ARE phi. 377/233 = φ to 4 decimal places. Outermost shell.'
  }
];

// Color scheme — hardware + animal categories
const COLORS = {
  fastener:  { fill: '#c9a84c', stroke: '#f0d080', text: '#0a0a0f' },
  connector: { fill: '#2dd4bf', stroke: '#5eead4', text: '#0a0a0f' },
  pipe:      { fill: '#a78bfa', stroke: '#c4b5fd', text: '#0a0a0f' },
  bracket:   { fill: '#fb7185', stroke: '#fda4af', text: '#0a0a0f' },
  cephalopod:{ fill: '#7c3aed', stroke: '#a78bfa', text: '#ffffff' },
  bird:      { fill: '#0891b2', stroke: '#22d3ee', text: '#ffffff' },
  mammal:    { fill: '#b45309', stroke: '#f59e0b', text: '#ffffff' },
  arachnid:  { fill: '#065f46', stroke: '#34d399', text: '#ffffff' },
  insect:    { fill: '#be185d', stroke: '#f472b6', text: '#ffffff' },
  default:   { fill: '#4b5563', stroke: '#9ca3af', text: '#ffffff' }
};

function getColor(cat) { return COLORS[cat] || COLORS.default; }

// Canvas setup
const wrap = document.getElementById('mandala-wrap');
const mc = document.getElementById('mandala-canvas');
const ic = document.getElementById('interaction-canvas');

let W, H, cx, cy, baseR;
let selectedNode = null;
let hoveredNode = null;
let nodePositions = [];
let animFrame = 0;

function resize() {
  const size = wrap.offsetWidth;
  [mc, ic].forEach(c => {
    c.width = size * devicePixelRatio;
    c.height = size * devicePixelRatio;
    c.style.width = size + 'px';
    c.style.height = size + 'px';
  });
  W = H = size * devicePixelRatio;
  cx = W / 2; cy = H / 2;
  baseR = W * 0.06;
  computePositions();
  draw();
}

// Map orbit radius to visual radius (log scale so outer nodes aren't invisible)
function orbitToVisual(orbit) {
  const minR = baseR * 1.5;
  const maxR = W * 0.44;
  const maxOrbit = 108;
  const t = Math.log(1 + orbit) / Math.log(1 + maxOrbit);
  return minR + t * (maxR - minR);
}

function computePositions() {
  nodePositions = [];

  // Fixed angles for known hardware nodes
  const fixedAngles = {
    'UNI001': -Math.PI/2,
    'UNI002': -Math.PI/2,
    'UNI003': Math.PI * 0.75,
    'UNI004': Math.PI * 1.1,
    'UNI005': -Math.PI * 0.15,
    'UNI006': Math.PI * 0.55,
    'UNI007': Math.PI * 1.4,
    'UNI008': Math.PI * 1.25,
    'UNI009': -Math.PI * 0.3,
    'UNI010': Math.PI * 0.2,
  };

  // Auto-distribute unknown nodes evenly around their orbit
  // Group by orbit shell for even spacing
  const orbitGroups = {};
  NODES.forEach(n => {
    if (!fixedAngles[n.id]) {
      const key = Math.round(n.orbit * 10);
      if (!orbitGroups[key]) orbitGroups[key] = [];
      orbitGroups[key].push(n.id);
    }
  });

  const autoAngles = {};
  Object.values(orbitGroups).forEach(group => {
    group.forEach((id, i) => {
      autoAngles[id] = (2 * Math.PI * i / group.length) + Math.PI * 0.1;
    });
  });

  const isCenter = n => n.id === 'UNI001' || (n.orbit <= 1.1 && NODES.filter(x => x.orbit <= 1.1).length === 1);

  NODES.forEach(n => {
    const r = orbitToVisual(n.orbit);
    const angle = fixedAngles[n.id] ?? autoAngles[n.id] ?? (Math.random() * Math.PI * 2);
    nodePositions.push({
      node: n,
      x: cx + r * Math.cos(angle),
      y: cy + r * Math.sin(angle),
      r: baseR * (n.orbit <= 1.1 ? 1.4 : 0.9),
      angle
    });
  });
}

function draw() {
  animFrame++;
  const ctx = mc.getContext('2d');
  ctx.clearRect(0, 0, W, H);

  // Background glow at center
  const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, W * 0.5);
  grd.addColorStop(0, 'rgba(201,168,76,0.04)');
  grd.addColorStop(0.5, 'rgba(45,212,191,0.02)');
  grd.addColorStop(1, 'transparent');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, W, H);

  // Draw orbital rings
  const orbits = [1, PHI, PHI*PHI, PHI*PHI*PHI, 10, 30, 75, 108];
  orbits.forEach((o, i) => {
    const r = orbitToVisual(o);
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(201,168,76,${0.08 - i*0.008})`;
    ctx.lineWidth = 0.5;
    ctx.setLineDash([3, 6]);
    ctx.stroke();
    ctx.setLineDash([]);
  });

  // Draw covalent links
  const visibleIds = new Set(
    nodePositions.filter(np => ACTIVE_FILTERS.has(np.node.lattice)).map(np => np.node.id)
  );

  nodePositions.forEach(np => {
    if (!ACTIVE_FILTERS.has(np.node.lattice)) return;

    (np.node.links || []).forEach(linkId => {
      const target = nodePositions.find(p => p.node.id === linkId);
      if (!target) return;
      if (!visibleIds.has(linkId)) return;
      if (linkId < np.node.id) return; // avoid duplicates

      const crossDomain = np.node.lattice !== target.node.lattice;
      const isHighlighted = selectedNode &&
        (selectedNode.id === np.node.id || selectedNode.id === linkId);

      ctx.beginPath();
      ctx.moveTo(np.x, np.y);
      ctx.lineTo(target.x, target.y);

      if (crossDomain) {
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = isHighlighted
          ? 'rgba(184,115,51,0.9)'   // copper bright
          : 'rgba(184,115,51,0.35)'; // copper dim
        ctx.lineWidth = isHighlighted ? 2 : 1.2;
      } else {
        ctx.setLineDash([]);
        ctx.strokeStyle = isHighlighted
          ? 'rgba(201,168,76,0.7)'
          : 'rgba(201,168,76,0.12)';
        ctx.lineWidth = isHighlighted ? 1.5 : 0.7;
      }
      ctx.stroke();
      ctx.setLineDash([]);

      if (isHighlighted) {
        const mx = (np.x + target.x) / 2;
        const my = (np.y + target.y) / 2;
        ctx.beginPath();
        ctx.arc(mx, my, crossDomain ? 3 : 2, 0, Math.PI * 2);
        ctx.fillStyle = crossDomain ? 'rgba(184,115,51,0.8)' : 'rgba(201,168,76,0.5)';
        ctx.fill();

        // Label cross-domain links
        if (crossDomain) {
          ctx.font = `${baseR * 0.3}px Space Mono`;
          ctx.fillStyle = 'rgba(184,115,51,0.7)';
          ctx.textAlign = 'center';
          ctx.fillText('⟷', mx, my - 8);
        }
      }
    });
  });

  // Draw nodes
  // Draw nodes — filter by active lattice
  nodePositions.forEach(np => {
    if (!ACTIVE_FILTERS.has(np.node.lattice)) return;

    const n = np.node;
    const colors = getColor(n.category);
    // CLR nodes use their own emergent color
    const fillColor = n.hex || colors.fill;
    const strokeColor = n.hex ? n.hex : colors.stroke;
    const textColor = colors.text;

    const isSelected = selectedNode && selectedNode.id === n.id;
    const isHovered = hoveredNode && hoveredNode.id === n.id;
    const pulse = isSelected ? (0.85 + 0.15 * Math.sin(animFrame * 0.05)) : 1;

    // Outer glow
    if (isSelected || isHovered) {
      const glow = ctx.createRadialGradient(np.x, np.y, 0, np.x, np.y, np.r * 2.5);
      glow.addColorStop(0, fillColor + '40');
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(np.x, np.y, np.r * 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Pulse ring for selected
    if (isSelected) {
      ctx.beginPath();
      ctx.arc(np.x, np.y, np.r * (1.6 + 0.3 * Math.sin(animFrame * 0.05)), 0, Math.PI * 2);
      ctx.strokeStyle = strokeColor + '60';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // CLR nodes get a diamond shape instead of circle to distinguish them
    if (n.category === 'color') {
      ctx.save();
      ctx.translate(np.x, np.y);
      ctx.rotate(Math.PI / 4);
      ctx.beginPath();
      const s = np.r * pulse * 1.1;
      ctx.rect(-s/2, -s/2, s, s);
      const nodeGrd = ctx.createRadialGradient(-s*0.3, -s*0.3, 0, 0, 0, s);
      nodeGrd.addColorStop(0, fillColor + 'ff');
      nodeGrd.addColorStop(1, fillColor + 'aa');
      ctx.fillStyle = nodeGrd;
      ctx.fill();
      ctx.strokeStyle = isSelected ? fillColor : fillColor + '88';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.stroke();
      ctx.restore();
    } else {
      // Node circle
      ctx.beginPath();
      ctx.arc(np.x, np.y, np.r * pulse, 0, Math.PI * 2);
      const nodeGrd = ctx.createRadialGradient(
        np.x - np.r * 0.3, np.y - np.r * 0.3, 0,
        np.x, np.y, np.r
      );
      nodeGrd.addColorStop(0, strokeColor);
      nodeGrd.addColorStop(1, fillColor);
      ctx.fillStyle = nodeGrd;
      ctx.fill();
      ctx.strokeStyle = isSelected ? strokeColor : fillColor + 'aa';
      ctx.lineWidth = isSelected ? 2 : 1;
      ctx.stroke();
    }

    // Node ID text
    ctx.fillStyle = textColor;
    ctx.font = `bold ${np.r * 0.45}px Space Mono`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Shorten ID for display
    const displayId = n.id.replace('UNI','U').replace('ANM','A').replace('CLR','C');
    ctx.fillText(displayId, np.x, np.y - np.r * 0.15);

    // Note text (or species for animals, or color for CLR)
    ctx.font = `${np.r * 0.38}px Space Mono`;
    const subLabel = n.emergent_color
      ? n.emergent_color.split('-')[0]  // first word of color
      : (n.species ?? n.note);
    ctx.fillText(subLabel, np.x, np.y + np.r * 0.3);

    // Spin indicator
    const spinY = np.y - np.r - 6;
    ctx.font = `${np.r * 0.5}px serif`;
    ctx.fillStyle = n.spin === 'up' ? '#2dd4bf' : '#fb7185';
    ctx.fillText(n.spin === 'up' ? '↑' : '↓', np.x, spinY);
  });

  // Central phi marker
  ctx.font = `bold ${baseR * 0.5}px Cinzel`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'rgba(201,168,76,0.3)';
  ctx.fillText('φ', cx, cy + W * 0.36);

  requestAnimationFrame(draw);
}

// Hit detection
function getNodeAt(x, y) {
  const rect = ic.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const cx2 = (x - rect.left) * scaleX;
  const cy2 = (y - rect.top) * scaleY;

  for (const np of nodePositions) {
    const dx = cx2 - np.x;
    const dy = cy2 - np.y;
    if (Math.sqrt(dx*dx + dy*dy) < np.r * 1.5) return np.node;
  }
  return null;
}

ic.addEventListener('mousemove', e => {
  hoveredNode = getNodeAt(e.clientX, e.clientY);
  ic.style.cursor = hoveredNode ? 'pointer' : 'crosshair';
});

ic.addEventListener('click', e => {
  const node = getNodeAt(e.clientX, e.clientY);
  if (node) {
    selectedNode = node;
    showNodeInfo(node);
  }
});

ic.addEventListener('touchend', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const node = getNodeAt(t.clientX, t.clientY);
  if (node) {
    selectedNode = node;
    showNodeInfo(node);
  }
});

function showNodeInfo(n) {
  document.getElementById('hint-text').classList.add('hidden');
  const nd = document.getElementById('node-display');
  nd.classList.add('active');

  document.getElementById('nd-id').textContent = n.id;

  // Category + lattice label
  const latticeLabel = n.lattice ? ` · [${n.lattice}]` : '';
  document.getElementById('nd-category').textContent = n.category + latticeLabel;

  // Note — or musical interval for CLR nodes
  document.getElementById('nd-note').textContent = n.musical_interval || n.note || '?';

  const spinEl = document.getElementById('nd-spin');
  spinEl.textContent = 'spin ' + (n.spin||'?') + (n.spin === 'up' ? ' ↑' : ' ↓');
  spinEl.className = 'node-spin spin-' + (n.spin||'up');

  // Adaptive spec grid depending on node type
  if (n.category === 'color') {
    document.getElementById('nd-diam').textContent = n.inputs?.[0] || '—';
    document.getElementById('nd-len').textContent = n.inputs?.[1] || '—';
    document.getElementById('nd-orbit').textContent = n.orbit;
    document.getElementById('nd-phi').textContent = 'φ^' + n.phi_index;
    document.getElementById('nd-weight').textContent = n.emergent_color || '—';
    document.getElementById('nd-bond').textContent = (n.bond_angle||'—') + '°';
    // Update spec labels for color nodes
    document.querySelector('#nd-diam').previousElementSibling?.remove();
    document.getElementById('nd-diam').parentElement.querySelector('.spec-label').textContent = 'input 1';
    document.getElementById('nd-len').parentElement.querySelector('.spec-label').textContent = 'input 2';
    document.getElementById('nd-weight').parentElement.querySelector('.spec-label').textContent = 'color';
  } else if (n.species) {
    // Animal node
    document.getElementById('nd-diam').textContent = n.size_cm + 'cm';
    document.getElementById('nd-len').textContent = n.category;
    document.getElementById('nd-orbit').textContent = n.orbit;
    document.getElementById('nd-phi').textContent = 'φ^' + n.phi_index;
    document.getElementById('nd-weight').textContent = (n.behaviors||[]).length + ' behaviors';
    document.getElementById('nd-bond').textContent = (n.bond_angle||'—') + '°';
    document.getElementById('nd-diam').parentElement.querySelector('.spec-label').textContent = 'size';
    document.getElementById('nd-len').parentElement.querySelector('.spec-label').textContent = 'class';
    document.getElementById('nd-weight').parentElement.querySelector('.spec-label').textContent = 'behaviors';
  } else {
    // Hardware node
    document.getElementById('nd-diam').textContent = (n.diameter_mm||'—') + 'mm';
    document.getElementById('nd-len').textContent = (n.length_mm||'—') + 'mm';
    document.getElementById('nd-orbit').textContent = n.orbit;
    document.getElementById('nd-phi').textContent = 'φ^' + n.phi_index + ' ≈ ' + Math.pow(PHI, n.phi_index).toFixed(3);
    document.getElementById('nd-weight').textContent = (n.weight_g||'—') + 'g';
    document.getElementById('nd-bond').textContent = (n.bond_angle||'—') + '°';
    document.getElementById('nd-diam').parentElement.querySelector('.spec-label').textContent = 'diameter';
    document.getElementById('nd-len').parentElement.querySelector('.spec-label').textContent = 'length';
    document.getElementById('nd-weight').parentElement.querySelector('.spec-label').textContent = 'weight';
  }

  document.getElementById('nd-links').textContent = (n.links||[]).join(' · ') || 'none';
  document.getElementById('nd-puzzle').textContent = '◈ ' + (n.puzzle || n.description || '');

  // Show behaviors for animals
  const existing = document.getElementById('nd-behaviors');
  if (existing) existing.remove();
  if (n.behaviors && n.behaviors.length) {
    const bDiv = document.createElement('div');
    bDiv.id = 'nd-behaviors';
    bDiv.style.cssText = 'font-size:0.6rem;color:var(--violet);margin-top:0.4rem;';
    bDiv.textContent = '↳ ' + n.behaviors.join(' · ');
    document.getElementById('nd-puzzle').after(bDiv);
  }

  callAPI('pieces', n.id);
}

function callAPI(endpoint, param) {
  const resp = document.getElementById('api-response');
  resp.classList.add('active');

  let data = {};

  if (endpoint === 'pieces') {
    const node = NODES.find(n => n.id === param);
    if (node) {
      data = {
        id: node.id,
        category: node.category,
        note: node.note,
        spin: node.spin,
        orbit_radius: node.orbit,
        phi_index: node.phi_index,
        phi_value: parseFloat(Math.pow(PHI, node.phi_index).toFixed(6)),
        links: node.links,
        // hardware fields
        ...(node.diameter_mm && { diameter_mm: node.diameter_mm }),
        ...(node.length_mm && { length_mm: node.length_mm }),
        ...(node.weight_g && { weight_g: node.weight_g }),
        // animal fields
        ...(node.species && { species: node.species }),
        ...(node.size_cm && { size_cm: node.size_cm }),
        ...(node.behaviors && { behaviors: node.behaviors }),
        bond_angle: node.bond_angle,
        tetrahedral_geometry: {
          angles: Array(4).fill(node.bond_angle),
          bond_length_ratio: parseFloat((node.orbit / Math.pow(PHI, node.phi_index)).toFixed(4))
        },
        description: node.description,
        puzzle: node.puzzle
      };
    } else {
      data = { error: `node ${param} not found`, available: NODES.map(n => n.id) };
    }
  } else if (endpoint === 'graph') {
    const ids = param.split('-');
    const nodes = ids.map(id => NODES.find(n => n.id === id)).filter(Boolean);
    const links = [];
    nodes.forEach(n => {
      (n.links || []).forEach(lid => {
        if (ids.includes(lid) && !links.find(l => l.from === lid && l.to === n.id)) {
          links.push({ from: n.id, to: lid });
        }
      });
    });
    const phiDrift = nodes.reduce((acc, n) =>
      acc + Math.abs(n.orbit - Math.pow(PHI, n.phi_index)) / n.orbit, 0) / Math.max(nodes.length, 1);

    data = {
      nodes: ids,
      found: nodes.map(n => n.id),
      links,
      mandala_stable: links.length >= nodes.length - 1,
      phi_consistency: parseFloat((1 - phiDrift).toFixed(3)),
      covalent_integrity: true,
      note_harmony: nodes.map(n => n.note).join(' → '),
      orbit_sequence: nodes.map(n => n.orbit)
    };
  } else if (endpoint === 'build') {
    const maxOrbit = Math.max(...NODES.map(n => n.orbit));
    data = {
      mandala_id: 'MANDALA_001',
      source: 'Bits/pieces.json',
      nodes_loaded: NODES.length,
      categories: [...new Set(NODES.map(n => n.category))],
      generated_nodes: NODES.map(n => ({
        id: n.id,
        category: n.category,
        note: n.note,
        orbit: n.orbit,
        spin: n.spin
      })),
      stability_score: 0.997,
      phi_alignment_score: 0.999,
      covalent_integrity: true,
      max_orbit: maxOrbit,
      proof_node: NODES.find(n => n.diameter_mm === 233 || n.length_mm === 377)?.id || 'see pieces.json',
      phi_proof: '377/233 = ' + (377/233).toFixed(10)
    };
  } else if (endpoint === 'validate') {
    const fibNums = new Set([1,1,2,3,5,8,13,21,34,55,89,144,233,377]);
    const fibNodes = NODES.filter(n =>
      fibNums.has(n.diameter_mm) || fibNums.has(n.length_mm) || fibNums.has(n.size_cm)
    ).map(n => n.id);

    data = {
      mandala_id: param,
      source: 'Bits/pieces.json',
      nodes_count: NODES.length,
      stability_score: 0.995,
      phi_consistency: 0.998,
      covalent_integrity: true,
      notes_coherence: true,
      orbits_coherence: true,
      fibonacci_nodes: fibNodes,
      orbit_range: [Math.min(...NODES.map(n=>n.orbit)), Math.max(...NODES.map(n=>n.orbit))],
      categories_present: [...new Set(NODES.map(n => n.category))],
      phi_proof: '377/233 = ' + (377/233).toFixed(10),
      dead_parrot_warranty: 'active'
    };
  }

  resp.textContent = JSON.stringify(data, null, 2);
}

// Init — load data then start
window.addEventListener('resize', resize);

async function init() {
  await loadNodes();
  resize();
}

init();
</script>

</body>
</html>
